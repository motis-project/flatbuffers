// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_REFLECTION_REFLECTION_H_
#define FLATBUFFERS_GENERATED_REFLECTION_REFLECTION_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/namespace.h"

namespace reflection {

struct Type;

struct KeyValue;

struct EnumVal;

struct Enum;

struct Field;

struct Object;

struct Schema;

enum BaseType {
  None = 0,
  UType = 1,
  Bool = 2,
  Byte = 3,
  UByte = 4,
  Short = 5,
  UShort = 6,
  Int = 7,
  UInt = 8,
  Long = 9,
  ULong = 10,
  Float = 11,
  Double = 12,
  String = 13,
  Vector = 14,
  Obj = 15,
  Union = 16,
  MIN = None,
  MAX = Union
};

inline const char **EnumNamesBaseType() {
  static const char *names[] = { "None", "UType", "Bool", "Byte", "UByte", "Short", "UShort", "Int", "UInt", "Long", "ULong", "Float", "Double", "String", "Vector", "Obj", "Union", nullptr };
  return names;
}

inline const char *EnumNameBaseType(BaseType e) { return EnumNamesBaseType()[static_cast<int>(e)]; }

struct Type FLATBUFFERS_FINAL_CLASS : private FLATBUFFERS_NAMESPACE::Table {
  enum {
    VT_BASE_TYPE = 4,
    VT_ELEMENT = 6,
    VT_INDEX = 8
  };
  BaseType base_type() const { return static_cast<BaseType>(GetField<int8_t>(VT_BASE_TYPE, 0)); }
  BaseType element() const { return static_cast<BaseType>(GetField<int8_t>(VT_ELEMENT, 0)); }
  int32_t index() const { return GetField<int32_t>(VT_INDEX, -1); }
  bool Verify(FLATBUFFERS_NAMESPACE::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BASE_TYPE) &&
           VerifyField<int8_t>(verifier, VT_ELEMENT) &&
           VerifyField<int32_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
};

struct TypeBuilder {
  FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb_;
  FLATBUFFERS_NAMESPACE::uoffset_t start_;
  void add_base_type(BaseType base_type) { fbb_.AddElement<int8_t>(Type::VT_BASE_TYPE, static_cast<int8_t>(base_type), 0); }
  void add_element(BaseType element) { fbb_.AddElement<int8_t>(Type::VT_ELEMENT, static_cast<int8_t>(element), 0); }
  void add_index(int32_t index) { fbb_.AddElement<int32_t>(Type::VT_INDEX, index, -1); }
  TypeBuilder(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TypeBuilder &operator=(const TypeBuilder &);
  FLATBUFFERS_NAMESPACE::Offset<Type> Finish() {
    auto o = FLATBUFFERS_NAMESPACE::Offset<Type>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline FLATBUFFERS_NAMESPACE::Offset<Type> CreateType(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb,
   BaseType base_type = None,
   BaseType element = None,
   int32_t index = -1) {
  TypeBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_element(element);
  builder_.add_base_type(base_type);
  return builder_.Finish();
}

struct KeyValue FLATBUFFERS_FINAL_CLASS : private FLATBUFFERS_NAMESPACE::Table {
  enum {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const FLATBUFFERS_NAMESPACE::String *key() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_KEY); }
  bool KeyCompareLessThan(const KeyValue *o) const { return *key() < *o->key(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(key()->c_str(), val); }
  const FLATBUFFERS_NAMESPACE::String *value() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_VALUE); }
  bool Verify(FLATBUFFERS_NAMESPACE::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_KEY) &&
           verifier.Verify(key()) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb_;
  FLATBUFFERS_NAMESPACE::uoffset_t start_;
  void add_key(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> key) { fbb_.AddOffset(KeyValue::VT_KEY, key); }
  void add_value(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> value) { fbb_.AddOffset(KeyValue::VT_VALUE, value); }
  KeyValueBuilder(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  KeyValueBuilder &operator=(const KeyValueBuilder &);
  FLATBUFFERS_NAMESPACE::Offset<KeyValue> Finish() {
    auto o = FLATBUFFERS_NAMESPACE::Offset<KeyValue>(fbb_.EndTable(start_, 2));
    fbb_.Required(o, KeyValue::VT_KEY);  // key
    return o;
  }
};

inline FLATBUFFERS_NAMESPACE::Offset<KeyValue> CreateKeyValue(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> key = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

struct EnumVal FLATBUFFERS_FINAL_CLASS : private FLATBUFFERS_NAMESPACE::Table {
  enum {
    VT_NAME = 4,
    VT_VALUE = 6,
    VT_OBJECT = 8
  };
  const FLATBUFFERS_NAMESPACE::String *name() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_NAME); }
  int64_t value() const { return GetField<int64_t>(VT_VALUE, 0); }
  bool KeyCompareLessThan(const EnumVal *o) const { return value() < o->value(); }
  int KeyCompareWithValue(int64_t val) const { return value() < val ? -1 : value() > val; }
  const Object *object() const { return GetPointer<const Object *>(VT_OBJECT); }
  bool Verify(FLATBUFFERS_NAMESPACE::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int64_t>(verifier, VT_VALUE) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_OBJECT) &&
           verifier.VerifyTable(object()) &&
           verifier.EndTable();
  }
};

struct EnumValBuilder {
  FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb_;
  FLATBUFFERS_NAMESPACE::uoffset_t start_;
  void add_name(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name) { fbb_.AddOffset(EnumVal::VT_NAME, name); }
  void add_value(int64_t value) { fbb_.AddElement<int64_t>(EnumVal::VT_VALUE, value, 0); }
  void add_object(FLATBUFFERS_NAMESPACE::Offset<Object> object) { fbb_.AddOffset(EnumVal::VT_OBJECT, object); }
  EnumValBuilder(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EnumValBuilder &operator=(const EnumValBuilder &);
  FLATBUFFERS_NAMESPACE::Offset<EnumVal> Finish() {
    auto o = FLATBUFFERS_NAMESPACE::Offset<EnumVal>(fbb_.EndTable(start_, 3));
    fbb_.Required(o, EnumVal::VT_NAME);  // name
    return o;
  }
};

inline FLATBUFFERS_NAMESPACE::Offset<EnumVal> CreateEnumVal(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name = 0,
   int64_t value = 0,
   FLATBUFFERS_NAMESPACE::Offset<Object> object = 0) {
  EnumValBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_object(object);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Enum FLATBUFFERS_FINAL_CLASS : private FLATBUFFERS_NAMESPACE::Table {
  enum {
    VT_NAME = 4,
    VT_VALUES = 6,
    VT_IS_UNION = 8,
    VT_UNDERLYING_TYPE = 10,
    VT_ATTRIBUTES = 12
  };
  const FLATBUFFERS_NAMESPACE::String *name() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_NAME); }
  bool KeyCompareLessThan(const Enum *o) const { return *name() < *o->name(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(name()->c_str(), val); }
  const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<EnumVal>> *values() const { return GetPointer<const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<EnumVal>> *>(VT_VALUES); }
  bool is_union() const { return GetField<uint8_t>(VT_IS_UNION, 0) != 0; }
  const Type *underlying_type() const { return GetPointer<const Type *>(VT_UNDERLYING_TYPE); }
  const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>> *attributes() const { return GetPointer<const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>> *>(VT_ATTRIBUTES); }
  bool Verify(FLATBUFFERS_NAMESPACE::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_VALUES) &&
           verifier.Verify(values()) &&
           verifier.VerifyVectorOfTables(values()) &&
           VerifyField<uint8_t>(verifier, VT_IS_UNION) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_UNDERLYING_TYPE) &&
           verifier.VerifyTable(underlying_type()) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_ATTRIBUTES) &&
           verifier.Verify(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct EnumBuilder {
  FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb_;
  FLATBUFFERS_NAMESPACE::uoffset_t start_;
  void add_name(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name) { fbb_.AddOffset(Enum::VT_NAME, name); }
  void add_values(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<EnumVal>>> values) { fbb_.AddOffset(Enum::VT_VALUES, values); }
  void add_is_union(bool is_union) { fbb_.AddElement<uint8_t>(Enum::VT_IS_UNION, static_cast<uint8_t>(is_union), 0); }
  void add_underlying_type(FLATBUFFERS_NAMESPACE::Offset<Type> underlying_type) { fbb_.AddOffset(Enum::VT_UNDERLYING_TYPE, underlying_type); }
  void add_attributes(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>>> attributes) { fbb_.AddOffset(Enum::VT_ATTRIBUTES, attributes); }
  EnumBuilder(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EnumBuilder &operator=(const EnumBuilder &);
  FLATBUFFERS_NAMESPACE::Offset<Enum> Finish() {
    auto o = FLATBUFFERS_NAMESPACE::Offset<Enum>(fbb_.EndTable(start_, 5));
    fbb_.Required(o, Enum::VT_NAME);  // name
    fbb_.Required(o, Enum::VT_VALUES);  // values
    fbb_.Required(o, Enum::VT_UNDERLYING_TYPE);  // underlying_type
    return o;
  }
};

inline FLATBUFFERS_NAMESPACE::Offset<Enum> CreateEnum(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<EnumVal>>> values = 0,
   bool is_union = false,
   FLATBUFFERS_NAMESPACE::Offset<Type> underlying_type = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>>> attributes = 0) {
  EnumBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_underlying_type(underlying_type);
  builder_.add_values(values);
  builder_.add_name(name);
  builder_.add_is_union(is_union);
  return builder_.Finish();
}

struct Field FLATBUFFERS_FINAL_CLASS : private FLATBUFFERS_NAMESPACE::Table {
  enum {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_ID = 8,
    VT_OFFSET = 10,
    VT_DEFAULT_INTEGER = 12,
    VT_DEFAULT_REAL = 14,
    VT_DEPRECATED = 16,
    VT_REQUIRED = 18,
    VT_KEY = 20,
    VT_ATTRIBUTES = 22
  };
  const FLATBUFFERS_NAMESPACE::String *name() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_NAME); }
  bool KeyCompareLessThan(const Field *o) const { return *name() < *o->name(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(name()->c_str(), val); }
  const Type *type() const { return GetPointer<const Type *>(VT_TYPE); }
  uint16_t id() const { return GetField<uint16_t>(VT_ID, 0); }
  uint16_t offset() const { return GetField<uint16_t>(VT_OFFSET, 0); }
  int64_t default_integer() const { return GetField<int64_t>(VT_DEFAULT_INTEGER, 0); }
  double default_real() const { return GetField<double>(VT_DEFAULT_REAL, 0.0); }
  bool deprecated() const { return GetField<uint8_t>(VT_DEPRECATED, 0) != 0; }
  bool required() const { return GetField<uint8_t>(VT_REQUIRED, 0) != 0; }
  bool key() const { return GetField<uint8_t>(VT_KEY, 0) != 0; }
  const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>> *attributes() const { return GetPointer<const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>> *>(VT_ATTRIBUTES); }
  bool Verify(FLATBUFFERS_NAMESPACE::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_TYPE) &&
           verifier.VerifyTable(type()) &&
           VerifyField<uint16_t>(verifier, VT_ID) &&
           VerifyField<uint16_t>(verifier, VT_OFFSET) &&
           VerifyField<int64_t>(verifier, VT_DEFAULT_INTEGER) &&
           VerifyField<double>(verifier, VT_DEFAULT_REAL) &&
           VerifyField<uint8_t>(verifier, VT_DEPRECATED) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRED) &&
           VerifyField<uint8_t>(verifier, VT_KEY) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_ATTRIBUTES) &&
           verifier.Verify(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct FieldBuilder {
  FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb_;
  FLATBUFFERS_NAMESPACE::uoffset_t start_;
  void add_name(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name) { fbb_.AddOffset(Field::VT_NAME, name); }
  void add_type(FLATBUFFERS_NAMESPACE::Offset<Type> type) { fbb_.AddOffset(Field::VT_TYPE, type); }
  void add_id(uint16_t id) { fbb_.AddElement<uint16_t>(Field::VT_ID, id, 0); }
  void add_offset(uint16_t offset) { fbb_.AddElement<uint16_t>(Field::VT_OFFSET, offset, 0); }
  void add_default_integer(int64_t default_integer) { fbb_.AddElement<int64_t>(Field::VT_DEFAULT_INTEGER, default_integer, 0); }
  void add_default_real(double default_real) { fbb_.AddElement<double>(Field::VT_DEFAULT_REAL, default_real, 0.0); }
  void add_deprecated(bool deprecated) { fbb_.AddElement<uint8_t>(Field::VT_DEPRECATED, static_cast<uint8_t>(deprecated), 0); }
  void add_required(bool required) { fbb_.AddElement<uint8_t>(Field::VT_REQUIRED, static_cast<uint8_t>(required), 0); }
  void add_key(bool key) { fbb_.AddElement<uint8_t>(Field::VT_KEY, static_cast<uint8_t>(key), 0); }
  void add_attributes(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>>> attributes) { fbb_.AddOffset(Field::VT_ATTRIBUTES, attributes); }
  FieldBuilder(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  FieldBuilder &operator=(const FieldBuilder &);
  FLATBUFFERS_NAMESPACE::Offset<Field> Finish() {
    auto o = FLATBUFFERS_NAMESPACE::Offset<Field>(fbb_.EndTable(start_, 10));
    fbb_.Required(o, Field::VT_NAME);  // name
    fbb_.Required(o, Field::VT_TYPE);  // type
    return o;
  }
};

inline FLATBUFFERS_NAMESPACE::Offset<Field> CreateField(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name = 0,
   FLATBUFFERS_NAMESPACE::Offset<Type> type = 0,
   uint16_t id = 0,
   uint16_t offset = 0,
   int64_t default_integer = 0,
   double default_real = 0.0,
   bool deprecated = false,
   bool required = false,
   bool key = false,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>>> attributes = 0) {
  FieldBuilder builder_(_fbb);
  builder_.add_default_real(default_real);
  builder_.add_default_integer(default_integer);
  builder_.add_attributes(attributes);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_offset(offset);
  builder_.add_id(id);
  builder_.add_key(key);
  builder_.add_required(required);
  builder_.add_deprecated(deprecated);
  return builder_.Finish();
}

struct Object FLATBUFFERS_FINAL_CLASS : private FLATBUFFERS_NAMESPACE::Table {
  enum {
    VT_NAME = 4,
    VT_FIELDS = 6,
    VT_IS_STRUCT = 8,
    VT_MINALIGN = 10,
    VT_BYTESIZE = 12,
    VT_ATTRIBUTES = 14
  };
  const FLATBUFFERS_NAMESPACE::String *name() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_NAME); }
  bool KeyCompareLessThan(const Object *o) const { return *name() < *o->name(); }
  int KeyCompareWithValue(const char *val) const { return strcmp(name()->c_str(), val); }
  const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Field>> *fields() const { return GetPointer<const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Field>> *>(VT_FIELDS); }
  bool is_struct() const { return GetField<uint8_t>(VT_IS_STRUCT, 0) != 0; }
  int32_t minalign() const { return GetField<int32_t>(VT_MINALIGN, 0); }
  int32_t bytesize() const { return GetField<int32_t>(VT_BYTESIZE, 0); }
  const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>> *attributes() const { return GetPointer<const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>> *>(VT_ATTRIBUTES); }
  bool Verify(FLATBUFFERS_NAMESPACE::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_FIELDS) &&
           verifier.Verify(fields()) &&
           verifier.VerifyVectorOfTables(fields()) &&
           VerifyField<uint8_t>(verifier, VT_IS_STRUCT) &&
           VerifyField<int32_t>(verifier, VT_MINALIGN) &&
           VerifyField<int32_t>(verifier, VT_BYTESIZE) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_ATTRIBUTES) &&
           verifier.Verify(attributes()) &&
           verifier.VerifyVectorOfTables(attributes()) &&
           verifier.EndTable();
  }
};

struct ObjectBuilder {
  FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb_;
  FLATBUFFERS_NAMESPACE::uoffset_t start_;
  void add_name(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name) { fbb_.AddOffset(Object::VT_NAME, name); }
  void add_fields(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Field>>> fields) { fbb_.AddOffset(Object::VT_FIELDS, fields); }
  void add_is_struct(bool is_struct) { fbb_.AddElement<uint8_t>(Object::VT_IS_STRUCT, static_cast<uint8_t>(is_struct), 0); }
  void add_minalign(int32_t minalign) { fbb_.AddElement<int32_t>(Object::VT_MINALIGN, minalign, 0); }
  void add_bytesize(int32_t bytesize) { fbb_.AddElement<int32_t>(Object::VT_BYTESIZE, bytesize, 0); }
  void add_attributes(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>>> attributes) { fbb_.AddOffset(Object::VT_ATTRIBUTES, attributes); }
  ObjectBuilder(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ObjectBuilder &operator=(const ObjectBuilder &);
  FLATBUFFERS_NAMESPACE::Offset<Object> Finish() {
    auto o = FLATBUFFERS_NAMESPACE::Offset<Object>(fbb_.EndTable(start_, 6));
    fbb_.Required(o, Object::VT_NAME);  // name
    fbb_.Required(o, Object::VT_FIELDS);  // fields
    return o;
  }
};

inline FLATBUFFERS_NAMESPACE::Offset<Object> CreateObject(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> name = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Field>>> fields = 0,
   bool is_struct = false,
   int32_t minalign = 0,
   int32_t bytesize = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<KeyValue>>> attributes = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_bytesize(bytesize);
  builder_.add_minalign(minalign);
  builder_.add_fields(fields);
  builder_.add_name(name);
  builder_.add_is_struct(is_struct);
  return builder_.Finish();
}

struct Schema FLATBUFFERS_FINAL_CLASS : private FLATBUFFERS_NAMESPACE::Table {
  enum {
    VT_OBJECTS = 4,
    VT_ENUMS = 6,
    VT_FILE_IDENT = 8,
    VT_FILE_EXT = 10,
    VT_ROOT_TABLE = 12
  };
  const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Object>> *objects() const { return GetPointer<const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Object>> *>(VT_OBJECTS); }
  const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Enum>> *enums() const { return GetPointer<const FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Enum>> *>(VT_ENUMS); }
  const FLATBUFFERS_NAMESPACE::String *file_ident() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_FILE_IDENT); }
  const FLATBUFFERS_NAMESPACE::String *file_ext() const { return GetPointer<const FLATBUFFERS_NAMESPACE::String *>(VT_FILE_EXT); }
  const Object *root_table() const { return GetPointer<const Object *>(VT_ROOT_TABLE); }
  bool Verify(FLATBUFFERS_NAMESPACE::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_OBJECTS) &&
           verifier.Verify(objects()) &&
           verifier.VerifyVectorOfTables(objects()) &&
           VerifyFieldRequired<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_ENUMS) &&
           verifier.Verify(enums()) &&
           verifier.VerifyVectorOfTables(enums()) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_FILE_IDENT) &&
           verifier.Verify(file_ident()) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_FILE_EXT) &&
           verifier.Verify(file_ext()) &&
           VerifyField<FLATBUFFERS_NAMESPACE::uoffset_t>(verifier, VT_ROOT_TABLE) &&
           verifier.VerifyTable(root_table()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb_;
  FLATBUFFERS_NAMESPACE::uoffset_t start_;
  void add_objects(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Object>>> objects) { fbb_.AddOffset(Schema::VT_OBJECTS, objects); }
  void add_enums(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Enum>>> enums) { fbb_.AddOffset(Schema::VT_ENUMS, enums); }
  void add_file_ident(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> file_ident) { fbb_.AddOffset(Schema::VT_FILE_IDENT, file_ident); }
  void add_file_ext(FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> file_ext) { fbb_.AddOffset(Schema::VT_FILE_EXT, file_ext); }
  void add_root_table(FLATBUFFERS_NAMESPACE::Offset<Object> root_table) { fbb_.AddOffset(Schema::VT_ROOT_TABLE, root_table); }
  SchemaBuilder(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SchemaBuilder &operator=(const SchemaBuilder &);
  FLATBUFFERS_NAMESPACE::Offset<Schema> Finish() {
    auto o = FLATBUFFERS_NAMESPACE::Offset<Schema>(fbb_.EndTable(start_, 5));
    fbb_.Required(o, Schema::VT_OBJECTS);  // objects
    fbb_.Required(o, Schema::VT_ENUMS);  // enums
    return o;
  }
};

inline FLATBUFFERS_NAMESPACE::Offset<Schema> CreateSchema(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &_fbb,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Object>>> objects = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::Vector<FLATBUFFERS_NAMESPACE::Offset<Enum>>> enums = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> file_ident = 0,
   FLATBUFFERS_NAMESPACE::Offset<FLATBUFFERS_NAMESPACE::String> file_ext = 0,
   FLATBUFFERS_NAMESPACE::Offset<Object> root_table = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_root_table(root_table);
  builder_.add_file_ext(file_ext);
  builder_.add_file_ident(file_ident);
  builder_.add_enums(enums);
  builder_.add_objects(objects);
  return builder_.Finish();
}

inline const reflection::Schema *GetSchema(const void *buf) { return FLATBUFFERS_NAMESPACE::GetRoot<reflection::Schema>(buf); }

inline bool VerifySchemaBuffer(FLATBUFFERS_NAMESPACE::Verifier &verifier) { return verifier.VerifyBuffer<reflection::Schema>(); }

inline const char *SchemaIdentifier() { return "BFBS"; }

inline bool SchemaBufferHasIdentifier(const void *buf) { return FLATBUFFERS_NAMESPACE::BufferHasIdentifier(buf, SchemaIdentifier()); }

inline const char *SchemaExtension() { return "bfbs"; }

inline void FinishSchemaBuffer(FLATBUFFERS_NAMESPACE::FlatBufferBuilder &fbb, FLATBUFFERS_NAMESPACE::Offset<reflection::Schema> root) { fbb.Finish(root, SchemaIdentifier()); }

}  // namespace reflection

#endif  // FLATBUFFERS_GENERATED_REFLECTION_REFLECTION_H_
